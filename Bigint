#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

const int Base = 10;

class BigInt {
private:
    vector<int> data;

    bool is_positive = true;

    void zeroCheck() {
        int zeros = 0;
        bool is_zero = true;
        for (size_t i=0; i < this->data.size(); ++i){
            if (data[i] == 0) ++zeros;
            else {
                is_zero = false;
                break;
            }
        }
        if (is_zero) {
            this->data.resize(1, 0);
            this->is_positive = true;
        }
        else if (zeros){
            vector <int> new_data;
            for (int i=zeros; i < this->data.size(); ++i){
                new_data.push_back(this->data[i]);
            }
            this->data = new_data;
        }
    }

public:
    BigInt() = default;

    BigInt &operator=(const BigInt &right);


    explicit BigInt(const string &s) {
        int res = 0, k = 0;
        is_positive = (s[0] == '-');
        for (auto i : s) {
            if (i == '-') continue;
            data.push_back((int) i - '0');
        }
        if (data[0] == 0) is_positive = true;
        data.push_back(res);
    }

    BigInt(const int &i){
        is_positive = (i >= 0);
        int res = abs(i);
        while (abs(i) > 0){
            data.push_back(res % 10);
            res /= 10;
        }
        reverse(data.begin(), data.end());
    }

    BigInt operator+(const BigInt &right) const;
    BigInt operator-(const BigInt &right) const;
    BigInt operator*(const BigInt &right) const;
    BigInt operator/(const BigInt &right) const;

    BigInt &operator+=(const BigInt &right);
    BigInt &operator-=(const BigInt &right);
    BigInt &operator*=(const BigInt &right);
    BigInt &operator/=(const BigInt &right);

    bool operator==(const BigInt &right) const;
    bool operator>=(const BigInt &right) const;
    bool operator<=(const BigInt &right) const;
    bool operator<(const BigInt &right) const;
    bool operator>(const BigInt &right) const;

    const BigInt operator--(int);
    BigInt operator--();
    const BigInt operator++(int);
    BigInt operator++();

    BigInt operator-();
    BigInt operator+() const;

    //istream &operator>>(istream &in);
    friend ostream &operator<<(ostream &os, const BigInt &a);

    static BigInt Plus(const BigInt& a, const BigInt& b) {
        BigInt result, left, right;
        if (a > b) {
            left = b;
            right = a;
        }
        else {
            left = a;
            right = b;
        }
        result.data.resize(max(left.data.size(), right.data.size()));
        int k = 0;
        size_t i;
        for (i = 0; i < left.data.size(); ++i) {
            result.data[result.data.size() - i - 1] =
                    (left.data[left.data.size() - i - 1] + right.data[right.data.size() - i - 1] + k) % Base;
            k = (left.data[left.data.size() - i - 1] + right.data[right.data.size() - i - 1] + k) / Base;
        }
        while (i < result.data.size()) {
            result.data[result.data.size() - i - 1] = (right.data[right.data.size() - i - 1] + k) % Base;
            k = (right.data[right.data.size() - i - 1] + k) / Base;
            ++i;
        }
        if (k > 0)
            result.data.insert(result.data.begin(), k);
        return result;
    }

    static BigInt Minus(const BigInt& a, const BigInt& b) {
        BigInt result, left, right;
        if (a > b) {
            left = b;
            right = a;
        }
        else {
            left = a;
            right = b;
        }
        result.data.resize(right.data.size());
        int k = 0;
        size_t i;
        for (i = 0; i < left.data.size(); ++i) {
            result.data[result.data.size() - i - 1] =
                    abs(right.data[right.data.size() - i - 1] - left.data[left.data.size() - i - 1] + k) % Base;
            k = (right.data[right.data.size() - i - 1] - left.data[left.data.size() - i - 1] + k) / Base;
        }
        while (i < result.data.size()) {
            result.data[result.data.size() - i - 1] = abs(right.data[right.data.size() - i - 1] + k) % Base;
            k = (right.data[right.data.size() - i - 1] + k) / Base;
            ++i;
        }
        if (k > 0)
            result.data.insert(result.data.begin(), abs(k));
        return result;
    }

    static BigInt abs1(const BigInt& a){
        BigInt res = a;
        res.is_positive = true;
        return res;
    }
};


BigInt BigInt::operator+(const BigInt &r) const{
    BigInt result;
    if (this->is_positive && r.is_positive) {
        result = Plus(abs1(*this), abs1(r));
        result.is_positive = true;
    }
    if (!this->is_positive && !r.is_positive){
        result = Plus(abs1(*this), abs1(r));
        result.is_positive = false;
    }
    if (this->is_positive && !r.is_positive){
        result = Minus(abs1(*this), abs1(r));
        result.is_positive = (abs1(r) > *this);
    }
    if (!this->is_positive && r.is_positive){
        result = Minus(abs1(*this), abs1(r));
        result.is_positive = (abs1(*this) > r);
    }
    return result;
}


istream& operator >> (std::istream &in, BigInt &a)
{
    string s;
    in >> s;
    a = BigInt(s);
    return in;
}

ostream& operator << (std::ostream &os, const BigInt &a)
{
    string s;
    if (!a.is_positive) s = '-';
    for (int i : a.data){
        s += to_string(i);
    }
    return os << s;
}

BigInt BigInt::operator+() const{
    return *this;
}


BigInt BigInt::operator-(const BigInt &r) const{
    BigInt result;
    if (this->is_positive && r.is_positive) {
        result = Minus(abs1(*this), abs1(r));
        result.is_positive = (*this > r);
    }
    if (!this->is_positive && !r.is_positive){
        result = Minus(abs1(*this), abs1(r));
        result.is_positive = (*this > r);
    }
    if (this->is_positive && !r.is_positive){
        result = Plus(abs1(*this), abs1(r));
        result.is_positive = true;
    }
    if (!this->is_positive && r.is_positive){
        result = Plus(abs1(*this), abs1(r));
        result.is_positive = false;
    }
    return result;
}

BigInt &BigInt::operator+=(const BigInt &right) {
    *this = *this + right;
    return *this;
}

BigInt &BigInt::operator-=(const BigInt &right) {
    *this = *this - right;
    return *this;
}

BigInt &BigInt::operator=(const BigInt &right) {
    if (this == &right) {
        return *this;
    }
    data = right.data;
    return *this;
}

BigInt BigInt::operator-() {
    this->is_positive = !this->is_positive;
    return *this;
}

bool BigInt::operator==(const BigInt &right) const{
    return !(*this > right) && !(*this < right);
}

bool BigInt::operator>(const BigInt &right) const{
    if (this->is_positive){
        if (!right.is_positive) return true;
        if (right.data.size() > this->data.size()) return false;
        if (this->data.size() < right.data.size()) return true;
        for (size_t i=0; i < this->data.size(); ++i){
            if (this->data[i] < right.data[i]) return false;
            if (this->data[i] > right.data[i]) return true;
        }
        return false;
    }
    else{
        if (!right.is_positive) return false;
        if (right.data.size() < this->data.size()) return false;
        if (this->data.size() > right.data.size()) return true;
        for (size_t i=0; i < this->data.size(); ++i){
            if (this->data[i] > right.data[i]) return false;
            if (this->data[i] < right.data[i]) return true;
        }
        return false;
    }
}

bool BigInt::operator<(const BigInt &right) const{
    return right > *this;
}

bool BigInt::operator<=(const BigInt &right) const{
    return *this < right || *this == right;
}

bool BigInt::operator>=(const BigInt &right) const{
    return *this == right || *this > right;
}

BigInt BigInt::operator++() {
    return *this + BigInt("1");
}

const BigInt BigInt::operator++(int){
    BigInt oldValue = *this;
    *this += BigInt("1");
    return oldValue;
}

BigInt BigInt::operator--() {
    return *this - BigInt("1");
}

const BigInt BigInt::operator--(int) {
    BigInt oldValue = *this;
    *this -= BigInt("1");
    return oldValue;
}

BigInt BigInt::operator/(const BigInt &right) const{

}

BigInt BigInt::operator*(const BigInt &right) const{
    if (this->data.size() == 1 && right.data.size() == 1){
        return BigInt(to_string(this->data[0] * right.data[0]));
    }
    BigInt res;
    res.is_positive = (this->is_positive && right.is_positive) || (!this->is_positive && !right.is_positive);
    BigInt A0("0"), B0("0");
    for (size_t i=0; i < this->data.size() / 2; ++i){
        A0.data.push_back(this->data[i]);
    }
    for (size_t i=0; i < right.data.size() / 2; ++i){
        B0.data.push_back(right.data[i]);
    }
    BigInt A1, B1;
    for (size_t i=this->data.size() / 2; i < this->data.size(); ++i){
        A1.data.push_back(this->data[i]);
    }
    for (size_t i=right.data.size() / 2; i < right.data.size(); ++i){
        B1.data.push_back(right.data[i]);
    }
    BigInt C0 = A0 * B0, C1 = A0 * B1, C2 = A1 * B0;
    size_t m1 = this->data.size() / 2, m2 = right.data.size() / 2;
    for (size_t i=0; i < m2; ++i){
        C2.data.push_back(0);
        C0.data.push_back(0);
    }
    for (size_t i=0; i < m1; ++i){
        C1.data.push_back(0);
        C0.data.push_back(0);
    }
    res = A1 * B1 + C0 + C1;
    return res;
}

BigInt &BigInt::operator*=(const BigInt &right) {

}

BigInt &BigInt::operator/=(const BigInt &right) {
    
}


int main()
{
    BigInt a, b;
    cin >> a >> b;
    cout << a * b;
}
