#include <iostream>
#include <vector>
#include <cmath>

const double INF = 1e9;
const double PI = M_PI;

using namespace std;

struct Point{
    double x, y;

    Point &operator=(const Point &right);

    Point(){
        x = 0;
        y = 0;
    }

    Point(double a, double b){
        x = a;
        y = b;
    }

    static double dist(const Point& A, const Point& B){
        return sqrt(pow(A.x - B.x, 2) + pow(A.y - B.y, 2));
    }

    static double angle(const Point& A, const Point& B, const Point& C){
        double ax = A.x - B.x, ay = A.y - B.y, bx = C.x - B.y, by = C.y - B.y;
        return acos((ax*bx + ay*by) / (dist(A, B) * dist(B, C)));
    }

};

bool operator ==(const Point &a, const Point &b){
    return (a.x == b.x && a.y == b.y);
}

bool operator !=(const Point &a, const Point &b){
    return !(a == b);
}

Point &Point::operator=(const Point &right) {
    if (*this == right){
        return *this;
    }
    this->x = right.x;
    this->y = right.y;
    return *this;
}


class Line{
private:
    double a{}, b{}, c{};
    double k{}, p{};

public:
    Line() = default;

    Line &operator=(const Line &right);

    Line(double x, double y, double z){
        a = x;
        b = y;
        c = z;
        k = (b == 0) ? INF : -a/b;
        p = (b == 0) ? INF : -c/a;
    }

    Line(double n, double m){
        k = n;
        p = m;
        a = k;
        b = -1;
        c = p;
    }

    Line(Point A, double x){
        k = x;
        a = k;
        b = -1;
        p = A.y - k * A.x;
        c = p;
    }

    Line(Point A, Point B){
        *this = Line(A.y - B.y, B.x - A.x, A.y * (A.x - B.x) + A.x * (B.y - A.y));
    }

    double get_a() const {
        return a;
    }

    double get_b() const {
        return b;
    }

    double get_c() const {
        return c;
    }

    double get_k() const {
        return k;
    }

    double get_p() const {
        return p;
    }

    static bool is_crossing(const Line& L, const Line& M){
        return L.k != M.k;
    }

    static Point cross(const Line& L, const Line& M){
        if (is_crossing(L, M)){
            double x = (M.k != 0) ? (L.k + L.p - M.p) / M.k : (M.k + M.p - L.p) / L.k;
            return Point(x, L.k * x + L.p);
        }
        throw exception();
    }

    static double angle(const Line& L, const Line& M){
        if (!is_crossing(L, M)){
            return 0;
        }
        Point A(-L.c/L.a, -L.c/L.b), C(-M.c/M.a, -M.c/M.b), B = cross(L, M);
        return min(Point::angle(A, B, C), PI - Point::angle(A, B, C));
    }

    static double dist(const Point& A, const Line& L){
        return abs(L.a*A.x + L.b*A.y + L.c) / sqrt(L.a*L.a + L.b*L.b);
    }

    Point get_perp(const Point& A) {
        double x, y;
        if (b == 0) {
            x = -c/a;
            y = A.y;
            return Point(x, y);
        }
        y = (a * A.x - a*a/b * A.y + c) / (a*a/b + b);
        x = A.x - a/b * (A.y - y);
        return Point(x, y);
    }
};


void rotate(Point &p, const Point& c, double angle) {
    p = Point(c.x + (p.x - c.x)*cos(angle) - (p.y - c.y)*sin(angle),
              c.y + (p.x - c.x)*sin(angle) - (p.y - c.y)*cos(angle));
}

void reflex(Point &p, const Point& c) {
    p = Point(2*c.x - p.x, 2*c.y - p.y);
}

void reflex(Point &p, Line L) {
    double x, y;
    if (L.get_a() != 0) {
        x = -(L.get_a() * p.x + 2 * L.get_b() * p.y - p.x * L.get_b() * L.get_b() / L.get_a()) /
            (L.get_a() + L.get_b() * L.get_b() / L.get_a());
        y = L.get_b() / L.get_a() * (x - p.x) + p.y;
    }
    else{
        x = p.x;
        y = -(2*p.x*L.get_a()/L.get_b() + p.y);
    }
    p = Point(x, y);
}

void scale(Point &p, const Point& c, double k) {
    p = Point(k * (p.x - c.x) + c.x, k * (p.y - c.y) + c.y);
}


bool operator ==(const Line &A, const Line &B){
    return (A.get_a() == B.get_a() && A.get_b() == B.get_b() && A.get_c() == B.get_c());
}

bool operator !=(const Line &a, const Line &b){
    return !(a == b);
}

Line &Line::operator=(const Line &right){
    if (*this == right){
        return *this;
    }
    this->a = right.a;
    this->b = right.b;
    this->c = right.c;
    this->k = right.k;
    this->p = right.p;
    return *this;
}


class Shape{
public:
    virtual double perimeter() = 0;
    virtual double area() = 0;
    virtual bool containsPoint(Point point) = 0;
    virtual void rotate(const Point& center, double angle) = 0;
    virtual void reflex(const Point& center) = 0;
    virtual void reflex(const Line& axis) = 0;
    virtual void scale(const Point& center, double coefficient) = 0;
    virtual bool operator==(const Shape& another){
        return false;
    }
    virtual bool operator!=(const Shape& another){
        return !(*this == another);
    }
};

class Polygon : public Shape{
private:
    vector <Point> vertices;

public:
    Polygon(vector <Point> &vert){
        vertices = vert;
    }

    template<typename... T>
    Polygon(const T&... args) {
        for (auto&& p : initializer_list<Point>{args...})
            vertices.push_back(p);
    }

    virtual int verticesCount(){
        return vertices.size();
    }

    virtual vector<Point> getVertices(){
        return vertices;
    }

    bool operator==(const Polygon& another){
        return this->vertices == another.vertices;
    }

    double perimeter() override{
        double res = 0;
        for (size_t i = 0; i < vertices.size(); ++i){
            if (i == 0) res += Point::dist(vertices[i], vertices[vertices.size() - 1]);
            else res += Point::dist(vertices[i], vertices[i - 1]);
        }
        return res;
    };

    double area() override{
        int n = vertices.size();
        double res = vertices[0].y * vertices[n-1].x - vertices[0].x * vertices[n-1].y;
        for (size_t i = 0; i < vertices.size() - 1; ++i){
            res = vertices[i].x * vertices[i+1].y - vertices[i].y * vertices[i+1].x;
        }
        return res/2;
    }

    bool isCongruentTo(const Polygon& another){
        bool ans = true;
        if (this->vertices.size() != another.vertices.size()) return false;
        int n = vertices.size();
        for (int k=0; k < n; ++k) {
            for (size_t i = 0; i < this->vertices.size(); ++i) {
                double a = Point::dist(this->vertices[i], this->vertices[(i + 1) % n]);
                double b = Point::dist(another.vertices[(i + k) % n], another.vertices[(i + k + 1) % n]);
                double c = Point::angle(this->vertices[i], this->vertices[(i + 1) % n],
                                        this->vertices[(i + 2) % n]);
                double d = Point::angle(this->vertices[(i + k) % n], this->vertices[(i + 1 + k) % n],
                                        this->vertices[(i + 2) % n]);
                ans = (a == b && c == d);
                if (!ans) break;
            }
        }
        return ans;
    }

    bool containsPoint(Point point) override;

    bool isSimilarTo(const Polygon& another){
        bool ans = true;
        if (this->vertices.size() != another.vertices.size()) return false;
        int n = vertices.size();
        for (int k=0; k < n; ++k) {
            for (size_t i = 0; i < this->vertices.size(); ++i) {
                double m = 0;
                double a = Point::dist(this->vertices[i], this->vertices[(i + 1) % n]);
                double b = Point::dist(another.vertices[(i + k) % n], another.vertices[(i + k + 1) % n]);
                double c = Point::angle(this->vertices[i], this->vertices[(i + 1) % n],
                                        this->vertices[(i + 2) % n]);
                double d = Point::angle(another.vertices[(i + k) % n], another.vertices[(i + 1 + k) % n],
                                        another.vertices[(i + 2 + k) % n]);
                ans = ((a/b == m || m == 0) && c == d);
                m = a/b;
                if (!ans) break;
            }
        }
        return ans;
    }

    void rotate(const Point& c, double angle) override {
        for (Point p : vertices){
            ::rotate(p, c, angle);
        }
    }

    void reflex(const Point& center) override {
        for (Point p : vertices){
            ::reflex(p, center);
        }
    }

    void reflex(const Line& L) override {
        for (Point p : vertices){
            ::reflex(p, L);
        }
    }

    void scale(const Point& center, double k) override {
        for (Point p : vertices) {
            ::scale(p, center, k);
        }
    }

    bool isConvex(){
        bool ans = true;
        int n = vertices.size();
        for (size_t i = 0; i < this->vertices.size(); ++i) {
            double c = Point::angle(this->vertices[i], this->vertices[(i + 1) % n],
                                    this->vertices[(i + 2) % n]);
            ans = (c < PI);
            if (!ans) break;
        }
        return ans;
    }
};



class Rectangle : public Polygon{
private:
    vector <Point> vertices;

public:

    Rectangle() = default;

    Rectangle(const Point &A, const Point &C, double k){
        double t = max(1/k, k);
        double x = (A.x + k * C.x) / (1 + t), y = (A.y + k * C.y) / (1 + t);
        Point B(x, y), D = B;
        ::reflex(D, Point((A.x+C.x)/2, (A.y+C.y)/2));
        vertices = {A, B, C, D};
    }

    Rectangle(vector <Point> &vert){
        vertices = vert;
    }

    Rectangle(const Point& A, const Point& B, const Point& C, const Point& D) {
        vertices.push_back(A);
        vertices.push_back(B);
        vertices.push_back(C);
        vertices.push_back(D);
    }

    pair<Line, Line> diagonals(){
        return make_pair(Line(vertices[0], vertices[1]), Line(vertices[1], vertices[3]));
    }

    Point center(){
        return Line::cross(this->diagonals().first, this->diagonals().second);
    }
};




class Ellipse : public Shape{
private:
    pair <Point, Point> focs;
    double a{}, b{}, exc{};

public:

    Ellipse() = default;

    Ellipse(const Point& A, const Point& B, double dist){
        focs = make_pair(A, B);
        a = dist/2;
        b = sqrt(a*a - pow(Point::dist(A, B)/2, 2));
        exc = sqrt(a*a - b*b)/a;
    }

    virtual Point centre(){
        return Point((focs.first.x + focs.second.x)/2, (focs.first.x + focs.second.x)/2);
    }

    virtual pair<Line, Line> directrices(){
        if (exc != 0){
            Line axis(focs.first, focs.second);
            double a1 = -axis.get_b(), b1 = axis.get_a();
            Point c = centre();
            double c1 = a/exc * sqrt(a1*a1 + b1*b1) - (a1*c.x + b1*c.y);
            double c2 = a/exc * sqrt(a1*a1 + b1*b1) - (a1*c.x + b1*c.y);
            return make_pair(Line(a1, b1, c1), Line(a1, b1, c2));
        }
        throw exception();
    }

    virtual pair<Point,Point> focuses(){
        return focs;
    }

    double perimeter() override{
        return 4*(PI*a*b + (a-b)*(a-b)) / (a + b);
    }

    double eccentricity(){
        return exc;
    }

    double area() override{
        return PI*a*b;
    }

    bool containsPoint(Point point) override{
        return (2*a >= Point::dist(point, focs.first) + Point::dist(point, focs.second));
    }

    bool operator==(const Ellipse &another){
        return (this->focs == another.focs && this->a == another.a && this->b == another.b);
    }

    bool isCongruentTo(const Ellipse& another) {
        return (this->a == another.a && this->b == another.b &&
                Point::dist(this->focs.first, this->focs.second) == Point::dist(another.focs.first, another.focs.second));
    }

    bool isSimilarTo(const Ellipse& another){
        return (this->a / another.a == this->b / another.b &&  this->b / another.b ==
                Point::dist(this->focs.first, this->focs.second) / Point::dist(another.focs.first, another.focs.second));
    }

    void rotate(const Point& c, double angle) override {
        ::rotate(focs.first, c, angle);
        ::rotate(focs.second, c, angle);
    }

    void reflex(const Point& c) override {
        ::reflex(focs.first, c);
        ::reflex(focs.second, c);
    }

    void reflex(const Line& L) override {
        ::reflex(focs.first, L);
        ::reflex(focs.second, L);
    }

    void scale(const Point& c, double k) override {
        ::scale(focs.first, c, k);
        ::scale(focs.second, c, k);
        a = abs(a*k);
        b = abs(b*k);
    }
};


class Circle : public Ellipse{
private:
    Point center;
    double rad;

public:

    Circle() = default;

    Circle(const Point& A, double p){
        center = A;
        rad = p;
    }

    double area() final{
        return PI*rad*rad;
    }

    double radius(){
        return rad;
    }

    Point get_centre(){
        return center;
    }

    bool containsPoint(Point point) final{
        return (rad >= Point::dist(point, center));
    }

    bool operator == (const Circle &another){
        return (this->center == another.center && this->rad == another.rad);
    }

    bool isCongruentTo(const Circle& another) {
        return (this->rad == another.rad);
    }

    bool isSimilarTo(const Circle& another) {
        return true;
    }

    void rotate(const Point& c, double angle) final {
        ::rotate(center, c, angle);
    }

    void reflex(const Point& c) final {
        ::reflex(center, c);
    }

    void reflex(const Line& L) final {
        ::reflex(center, L);
    }

    void scale(const Point& c, double k) final {
        ::scale(center, c, k);
        rad = abs(k*rad);
    }
};


class Triangle : public Polygon{
private:
    vector <Point> vertices;

public:
    Triangle() = default;

    Triangle(vector <Point> &vert){
        vertices = vert;
    }

    Triangle(const Point& A, const Point& B, const Point& C) {
        vertices.push_back(A);
        vertices.push_back(B);
        vertices.push_back(C);
    }

    Circle circumscribedCircle(){
        double x, y, d;
        Point A=vertices[0], B=vertices[1], C=vertices[2];
        d = 2*(A.x*(B.y-C.y)+B.x*(C.y-A.y)+C.x*(A.y-B.y));
        x = ((A.x*A.x+A.y*A.y)*(B.y-C.y) + (B.x*B.x+B.y*B.y)*(C.y-A.y) + (C.x*C.x+C.y*C.y)*(A.y-B.y)) / d;
        y = ((A.x*A.x+A.y*A.y)*(C.x-B.x) + (B.x*B.x+B.y*B.y)*(A.x-C.x) + (C.x*C.x+C.y*C.y)*(B.x-A.x)) / d;
        Point ctr(x, y);
        return Circle(ctr, Point::dist(ctr, A));
    }

    Circle inscribedCircle(){
        double r = 2 * this->area() / this->perimeter();
        Point A=vertices[0], B=vertices[1], C=vertices[2];
        double a = Point::dist(A, B), b = Point::dist(B, C), c = Point::dist(A, C);
        double x, y;
        x = (a*A.x + b*B.x + c*C.x) / (a + b + c);
        y = (a*A.y + b*B.y + c*C.y) / (a + b + c);
        return Circle(Point(x, y), r);
    }

    Point centroid() {
        Point A=vertices[0], B=vertices[1], C=vertices[2];
        return Point((A.x+B.x+C.x)/3, (A.y+B.y+C.y)/3);
    }

    Point orthocenter(){
        Point Ah = Line(vertices[1], vertices[2]).get_perp(vertices[0]);
        Point Ch = Line(vertices[0], vertices[1]).get_perp(vertices[2]);
        return Line::cross(Line(vertices[2], Ch), Line(vertices[0], Ah));
    }

    Circle ninePointsCircle(){
        Point Am((vertices[1].x+vertices[2].x)/2, (vertices[1].y+vertices[2].y)/2);
        Point Bm((vertices[0].x+vertices[2].x)/2, (vertices[0].y+vertices[2].y)/2);
        Point Cm((vertices[1].x+vertices[0].x)/2, (vertices[1].y+vertices[0].y)/2);
        Triangle T(Am, Bm, Cm);
        return T.circumscribedCircle();
    }

    Line EulerLine(){
        Point O1 = this->orthocenter(), O2 = this->ninePointsCircle().get_centre();
        return Line(O1, O2);
    }

    double area() final{
        double angle = sin(Point::angle(vertices[0], vertices[1], vertices[2]));
        return 0.5 * Point::dist(vertices[0], vertices[1]) * Point::dist(vertices[1], vertices[2]) * angle;
    }
};


bool Polygon::containsPoint(Point point) {
    double res = 0;
    for (size_t i = 0; i < vertices.size(); ++i){
        Triangle T(point, vertices[i], vertices[(i+1) % vertices.size()]);
        res += T.area();
    }
    return res == this->area();
}


class Square : public Rectangle{
private:
    vector <Point> vertices;

public:

    Square() = default;

    Square(vector <Point> &vert){
        vertices = vert;
    }

    Square(const Point &A, const Point &C){
        vertices.emplace_back(A);
        vertices.emplace_back(Point(A.x, C.y));
        vertices.emplace_back(C);
        vertices.emplace_back(Point(C.x, A.y));
    }

    Square(const Point& A, const Point& B, const Point& C, const Point& D) {
        vertices.push_back(A);
        vertices.push_back(B);
        vertices.push_back(C);
        vertices.push_back(D);
    }

    Circle circumscribedCircle(){
        Circle c(this->center(), Point::dist(this->center(), vertices[0]));
        return c;
    }

    Circle inscribedCircle(){
        Circle c(this->center(), Point::dist(this->vertices[0], this->vertices[1])/2);
        return c;
    }
};

