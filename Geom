#include <iostream>
#include <vector>
#include <cmath>

const double INF = 1e9;
const double PI = M_PI;
const double PREC = 1e-6;

using namespace std;

//std::precision(7);

struct Point{
    double x, y;

    Point &operator=(const Point &right);

    Point(){
        x = 0;
        y = 0;
    }

    Point(double a, double b){
        x = a;
        y = b;
    }

    static double dist(const Point& A, const Point& B){
        return sqrt(pow(A.x - B.x, 2) + pow(A.y - B.y, 2));
    }

    static double angle(const Point& A, const Point& B, const Point& C){
        double ax = A.x - B.x, ay = A.y - B.y, bx = C.x - B.x, by = C.y - B.y;
        if (dist(A, B) == 0 || dist(B, C) == 0) return 0;
        return acos((ax*bx + ay*by) / (dist(A, B) * dist(B, C)));
    }

};

bool operator==(const Point &a, const Point &b){
    return (abs(a.x - b.x) <= PREC && abs(a.y - b.y) <= PREC);
}

bool operator!=(const Point &a, const Point &b){
    return !(a == b);
}

Point &Point::operator=(const Point &right) {
    if (*this == right){
        return *this;
    }
    this->x = right.x;
    this->y = right.y;
    return *this;
}


class Line{
private:
    double a{}, b{}, c{};
    double k{}, p{};

public:
    Line() = default;

    Line &operator=(const Line &right);

    Line(double x, double y, double z){
        a = x;
        b = y;
        c = z;
        k = (b == 0) ? INF : -a/b;
        p = (b == 0) ? INF : -c/a;
    }

    Line(double n, double m){
        k = n;
        p = m;
        a = k;
        b = -1;
        c = p;
    }

    Line(Point A, double x){
        k = x;
        a = k;
        b = -1;
        p = A.y - k * A.x;
        c = p;
    }

    Line(Point A, Point B){
        *this = Line(A.y - B.y, B.x - A.x, A.y * (A.x - B.x) + A.x * (B.y - A.y));
    }

    double get_a() const {
        return a;
    }

    double get_b() const {
        return b;
    }

    double get_c() const {
        return c;
    }

    double get_k() const {
        return k;
    }

    double get_p() const {
        return p;
    }

    static bool is_crossing(const Line& L, const Line& M){
        return L.k != M.k;
    }

    static Point cross(const Line& L, const Line& M){
        if (is_crossing(L, M)){
            double x = (M.k != 0) ? (L.k + L.p - M.p) / M.k : (M.k + M.p - L.p) / L.k;
            return Point(x, L.k * x + L.p);
        }
        throw exception();
    }

    static double angle(const Line& L, const Line& M){
        if (!is_crossing(L, M)){
            return 0;
        }
        Point A(-L.c/L.a, -L.c/L.b), C(-M.c/M.a, -M.c/M.b), B = cross(L, M);
        return min(Point::angle(A, B, C), PI - Point::angle(A, B, C));
    }

    static double dist(const Point& A, const Line& L){
        return abs(L.a*A.x + L.b*A.y + L.c) / sqrt(L.a*L.a + L.b*L.b);
    }

    Point get_perp(const Point& A) {
        double x, y;
        if (b == 0) {
            x = -c/a;
            y = A.y;
            return Point(x, y);
        }
        y = (a * A.x - a*a/b * A.y + c) / (a*a/b + b);
        x = A.x - a/b * (A.y - y);
        return Point(x, y);
    }
};


void rotate(Point &p, const Point& c, double angle) {
    p = Point(c.x + (p.x - c.x)*cos(angle) - (p.y - c.y)*sin(angle),
              c.y + (p.x - c.x)*sin(angle) + (p.y - c.y)*cos(angle));
}

void reflex(Point &p, const Point& c) {
    p = Point(2*c.x - p.x, 2*c.y - p.y);
}

void reflex(Point &p, Line L) {
    double x, y;
    if (L.get_a() != 0) {
        x = -(L.get_a() * p.x + 2 * L.get_b() * p.y - p.x * L.get_b() * L.get_b() / L.get_a()) /
            (L.get_a() + L.get_b() * L.get_b() / L.get_a());
        y = L.get_b() / L.get_a() * (x - p.x) + p.y;
    }
    else{
        x = p.x;
        y = -(2*p.x*L.get_a()/L.get_b() + p.y);
    }
    p = Point(x, y);
}

void scale(Point &p, const Point& c, double k) {
    if (k == 0){
        p = c;
        return;
    }
    if (k != 1) p = Point((k * p.x - (k - 1) * c.x), (k * p.y - c.y * (k - 1)));
}


bool operator ==(const Line &A, const Line &B){
    return (A.get_a() == B.get_a() && A.get_b() == B.get_b() && A.get_c() == B.get_c());
}

bool operator !=(const Line &a, const Line &b){
    return !(a == b);
}

Line &Line::operator=(const Line &right){
    if (*this == right){
        return *this;
    }
    this->a = right.a;
    this->b = right.b;
    this->c = right.c;
    this->k = right.k;
    this->p = right.p;
    return *this;
}


class Shape{
public:
    virtual double perimeter() = 0;
    virtual double area() = 0;
    virtual bool containsPoint(Point point) = 0;
    virtual void rotate(const Point& center, double angle) = 0;
    virtual void reflex(const Point& center) = 0;
    virtual void reflex(const Line& axis) = 0;
    virtual void scale(const Point& center, double coefficient) = 0;
    virtual bool operator==(const Shape& another){
        return false;
    }
    virtual bool operator!=(const Shape& another){
        return !(*this == another);
    }

    virtual ~Shape() = default;
};

class Polygon : public Shape{
protected:
    vector <Point> vertices;

public:
    Polygon(vector <Point> &vert){
        vertices = vert;
    }

    template<typename... T>
    Polygon(const T&... args) {
        for (auto&& p : initializer_list<Point>{args...})
            vertices.push_back(p);
    }

    ~Polygon() override{
        vertices.clear();
        vertices.shrink_to_fit();
    }

    virtual int verticesCount(){
        return vertices.size();
    }

    virtual vector<Point> getVertices(){
        return vertices;
    }

    bool operator==(const Polygon& another){
        bool ans = (this->vertices.size() == another.vertices.size());
        if (!ans)
            return ans;
        int n = this->vertices.size();
        for (int k = 0; k < this->vertices.size(); ++k) {
            ans = true;
            for (size_t i = 0; i < vertices.size(); ++i) {
                ans = ans && (this->vertices[i] == another.vertices[(i + k) % n]);
                if (!ans) break;
            }
            if (ans) break;
        }
        if (ans) return ans;
        ans = true;
        for (int k = 0; k < this->vertices.size(); ++k) {
            ans = true;
            for (size_t i = 0; i < vertices.size(); ++i) {
                ans = ans && (this->vertices[i] == another.vertices[(n - i + k) % n]);
                if (!ans) break;
            }
            if (ans) break;
        }
        return ans;
    }

    bool operator!=(const Polygon& another){
        return !(*this == another);
    }

    double perimeter() override{
        double res = 0;
        for (size_t i = 0; i < vertices.size(); ++i){
            if (i == 0) res += Point::dist(vertices[i], vertices[vertices.size() - 1]);
            else res += Point::dist(vertices[i], vertices[i - 1]);
        }
        return res;
    };

    double area() override{
        int n = vertices.size();
        double res = vertices[0].y * vertices[n-1].x - vertices[0].x * vertices[n-1].y;
        for (size_t i = 0; i < vertices.size() - 1; ++i){
            res += vertices[i].x * vertices[i+1].y - vertices[i].y * vertices[i+1].x;
        }
        return abs(res/2);
    }

    bool isCongruentTo(const Polygon& another){
        bool ans = true;
        if (this->vertices.size() != another.vertices.size()) return false;
        int n = vertices.size();
        for (int k=0; k < n; ++k) {
            ans = true;
            for (size_t i = 0; i < this->vertices.size(); ++i) {
                double a = Point::dist(this->vertices[i], this->vertices[(i + 1) % n]);
                double b = Point::dist(another.vertices[(i + k) % n], another.vertices[(i + k + 1) % n]);
                double c = Point::angle(this->vertices[i], this->vertices[(i + 1) % n],
                                        this->vertices[(i + 2) % n]);
                double d = Point::angle(another.vertices[(i + k) % n], another.vertices[(i + 1 + k) % n],
                                        another.vertices[(i + 2) % n]);
                ans = ((abs(a - b) <= PREC) && abs(c - d) <= PREC);
                if (!ans) break;
            }
            if (ans) break;
        }
        if (ans) return ans;
        ans = true;
        for (int k=0; k < n; ++k) {
            ans = true;
            for (size_t i = 0; i < n; ++i) {
                double a = Point::dist(this->vertices[i], this->vertices[(n + i + 1) % n]);
                double b = Point::dist(another.vertices[(n - i + k) % n], another.vertices[(n - i + k - 1) % n]);
                double c = Point::angle(this->vertices[i], this->vertices[(n + i + 1) % n],
                                        this->vertices[(n + i + 2) % n]);
                double d = Point::angle(another.vertices[(n - i + k) % n], another.vertices[(n - i - 1 + k) % n],
                                        another.vertices[(n - i - 2 + k) % n]);
                ans = (abs(a - b) <= PREC && abs(c - d) <= PREC);
                if (!ans) break;
            }
            if (ans) break;
        }
        return ans;
    }

    bool containsPoint(Point point) override;

    bool isSimilarTo(const Polygon& another){
        bool ans = true;
        if (this->vertices.size() != another.vertices.size()) return false;
        int n = vertices.size();
        for (int k=0; k < n; ++k) {
            double m = 0;
            ans = true;
            for (size_t i = 0; i < this->vertices.size(); ++i) {
                double a = Point::dist(this->vertices[i], this->vertices[(i + 1) % n]);
                double b = Point::dist(another.vertices[(i + k) % n], another.vertices[(i + k + 1) % n]);
                double c = Point::angle(this->vertices[i], this->vertices[(i + 1) % n],
                        this->vertices[(i + 2) % n]);
                double d = Point::angle(another.vertices[(i + k) % n], another.vertices[(i + 1 + k) % n],
                        another.vertices[(i + 2 + k) % n]);
                ans = (abs(a/b - m) <= PREC || m == 0) && abs(c - d) <= PREC;
                m = a/b;
                if (!ans) break;
            }
            if (ans) break;
        }
        if (ans) return ans;
        ans = true;
        for (int k=0; k < n; ++k) {
            double m = 0;
            ans = true;
            for (size_t i = 0; i < n; ++i) {
                double a = Point::dist(this->vertices[i], this->vertices[(n + i + 1) % n]);
                double b = Point::dist(another.vertices[(n - i + k) % n], another.vertices[(n - i + k - 1) % n]);
                double c = Point::angle(this->vertices[i], this->vertices[(n + i + 1) % n],
                                        this->vertices[(n + i + 2) % n]);
                double d = Point::angle(another.vertices[(n - i + k) % n], another.vertices[(n - i - 1 + k) % n],
                                        another.vertices[(n - i - 2 + k) % n]);
                ans = (abs(a/b - m) <= PREC || m == 0) && abs(c - d) <= PREC;
                m = a/b;
                if (!ans) break;
            }
            if (ans) break;
        }
        return ans;
    }

    void rotate(const Point& c, double angle) override {
        for (size_t i=0; i < vertices.size(); ++i){
            ::rotate(vertices[i], c, angle);
        }
    }

    void reflex(const Point& center) override {
        for (size_t i=0; i < vertices.size(); ++i){
            ::reflex(vertices[i], center);
        }
    }

    void reflex(const Line& L) override {
        for (size_t i=0; i < vertices.size(); ++i){
            ::reflex(vertices[i], L);
        }
    }

    void scale(const Point& center, double k) override {
        for (size_t i=0; i < vertices.size(); ++i) {
            ::scale(vertices[i], center, k);
        }
    }

    bool isConvex() {
        bool ans = true;
        int n = vertices.size();
        for (size_t i = 0; i < this->vertices.size(); ++i) {
            Line L(vertices[i], vertices[(i + 2) % n]);
            ans = ((L.get_a() * vertices[(i + 1) % n].x + L.get_b() * vertices[(i + 1) % n].y + L.get_c()) *
                    (L.get_a() * vertices[(i + 3) % n].x + L.get_b() * vertices[(i + 3) % n].y + L.get_c()) < 0);
            if (!ans) break;
        }
        return ans;
    }
};



class Rectangle : public Polygon{
public:

    Rectangle() = default;

    Rectangle(const Point &A, const Point &C, double k){
        double t = max(1/k, k);
        double x = (A.x + k * C.x) / (1 + t), y = (A.y + k * C.y) / (1 + t);
        Point B(x, y), D = B;
        ::reflex(D, Point((A.x+C.x)/2, (A.y+C.y)/2));
        vertices = {A, B, C, D};
    }

    Rectangle(vector <Point> &vert){
        vertices = vert;
    }

    Rectangle(const Point& A, const Point& B, const Point& C, const Point& D) {
        vertices.push_back(A);
        vertices.push_back(B);
        vertices.push_back(C);
        vertices.push_back(D);
    }

    ~Rectangle() override {
        vertices.clear();
        vertices.shrink_to_fit();
    }

    pair<Line, Line> diagonals(){
        return make_pair(Line(vertices[0], vertices[1]), Line(vertices[1], vertices[3]));
    }

    Point center(){
        return Line::cross(this->diagonals().first, this->diagonals().second);
    }
};


class Ellipse : public Shape{
protected:
    pair <Point, Point> focs;
    double a = 0, b = 0, exc = 0;

public:

    Ellipse() = default;

    Ellipse(const Point& A, const Point& B, double dist){
        focs = make_pair(A, B);
        a = dist/2;
        b = sqrt(a*a - pow(Point::dist(A, B)/2, 2));
        exc = sqrt(a*a - b*b)/a;
    }

    ~Ellipse() override = default;

    double get_a() const{
        return a;
    }
    double get_b() const{
        return b;
    }

    virtual Point center() const{
        return Point((focs.first.x + focs.second.x)/2, (focs.first.x + focs.second.x)/2);
    }

    virtual pair<Line, Line> directrices(){
        if (exc != 0){
            Line axis(focs.first, focs.second);
            double a1 = -axis.get_b(), b1 = axis.get_a();
            Point c = center();
            double c1 = a/exc * sqrt(a1*a1 + b1*b1) - (a1*c.x + b1*c.y);
            double c2 = a/exc * sqrt(a1*a1 + b1*b1) - (a1*c.x + b1*c.y);
            return make_pair(Line(a1, b1, c1), Line(a1, b1, c2));
        }
        throw exception();
    }

    virtual pair<Point,Point> focuses() const{
        return focs;
    }

    double perimeter() override{
        return 4*(PI*a*b + (a-b)*(a-b)) / (a + b);
    }

    double eccentricity() const{
        return exc;
    }

    double area() override{
        return PI*a*b;
    }

    bool containsPoint(Point point) override{
        return (2*a >= Point::dist(point, focs.first) + Point::dist(point, focs.second));
    }

    virtual bool operator==(const Ellipse &another){
        return (this->focs == another.focs && abs(this->a - another.a) <= PREC &&
            abs(this->b - another.b) <= PREC);
    }

    virtual bool operator!=(const Ellipse& another){
        return !(*this == another);
    }

    virtual bool isCongruentTo(const Ellipse& another) {
        return (this->a == another.a && this->b == another.b &&
            abs(Point::dist(this->focs.first, this->focs.second) -
                Point::dist(another.focs.first, another.focs.second)) <= PREC);
    }

    virtual bool isSimilarTo(const Ellipse& another){
        if (another.focuses().first == another.focuses().second){
            return (this->focuses().first == this->focuses().second
                && abs(this->a / another.a - this->b / another.b) <= PREC);
        }
        return (this->a / another.a == this->b / another.b && abs(this->b / another.b -
            Point::dist(this->focs.first, this->focs.second) /
                Point::dist(another.focs.first, another.focs.second)) <= PREC);
    }

    void rotate(const Point& c, double angle) override {
        ::rotate(focs.first, c, angle);
        ::rotate(focs.second, c, angle);
    }

    void reflex(const Point& c) override {
        ::reflex(focs.first, c);
        ::reflex(focs.second, c);
    }

    void reflex(const Line& L) override {
        ::reflex(focs.first, L);
        ::reflex(focs.second, L);
    }

    void scale(const Point& c, double k) override {
        ::scale(focs.first, c, k);
        ::scale(focs.second, c, k);
        a = abs(a*k);
        b = abs(b*k);
    }
};


class Circle : public Ellipse{
private:
    Point centr;
    double rad = 0;

public:

    Circle() = default;

    Circle(const Point& A, double p){
        centr = A;
        rad = p;
        a = rad;
        b = rad;
        focs = make_pair(A, A);
    }

    ~Circle() override = default;

    double area() final{
        return PI*rad*rad;
    }

    double radius(){
        return rad;
    }

    Point center() const final {
        return centr;
    }

    bool containsPoint(Point point) final{
        return (rad >= Point::dist(point, centr));
    }

    bool operator==(const Circle &another){
        return (this->centr == another.centr && abs(this->rad - another.rad) <= PREC);
    }

    bool operator!=(const Circle &another){
        return !(*this == another);
    }

    bool operator==(const Ellipse &another) final{
        throw exception();
        return ((abs(this->rad - another.get_a()) <= PREC && abs(another.get_b() - this->rad) <= PREC) &&
            this->centr == another.center());
    }

    bool operator!=(const Ellipse &another) final{
        return !(*this == another);
    }

    bool isCongruentTo(const Circle& another) {
        return (abs(this->rad - another.rad) <= PREC);
    }

    bool isCongruentTo(const Ellipse& another) final {
        return (abs(this->rad - another.get_a()) <= PREC && abs(this->rad - another.get_b()) <= PREC &&
            another.focuses().first == another.focuses().second);
    }

    bool isSimilarTo(const Circle& another) {
        return true;
    }

    bool isSimilarTo(const Ellipse& another) final {
        return (another.focuses().first == another.focuses().second);
    }

    void rotate(const Point& c, double angle) final {
        ::rotate(centr, c, angle);
    }

    void reflex(const Point& c) final {
        ::reflex(centr, c);
    }

    void reflex(const Line& L) final {
        ::reflex(centr, L);
    }

    void scale(const Point& c, double k) final {
        ::scale(centr, c, k);
        rad = abs(k*rad);
    }
};


class Triangle : public Polygon{
public:
    Triangle() = default;

    Triangle(vector <Point> &vert){
        vertices = vert;
    }

    Triangle(const Point& A, const Point& B, const Point& C) {
        vertices.push_back(A);
        vertices.push_back(B);
        vertices.push_back(C);
    }

    ~Triangle() override{
        vertices.clear();
        vertices.shrink_to_fit();
    }

    Circle circumscribedCircle(){
        double x, y, d;
        Point A=vertices[0], B=vertices[1], C=vertices[2];
        d = 2*(A.x*(B.y-C.y)+B.x*(C.y-A.y)+C.x*(A.y-B.y));
        x = ((A.x*A.x+A.y*A.y)*(B.y-C.y) + (B.x*B.x+B.y*B.y)*(C.y-A.y) + (C.x*C.x+C.y*C.y)*(A.y-B.y)) / d;
        y = ((A.x*A.x+A.y*A.y)*(C.x-B.x) + (B.x*B.x+B.y*B.y)*(A.x-C.x) + (C.x*C.x+C.y*C.y)*(B.x-A.x)) / d;
        Point ctr(x, y);
        return Circle(ctr, Point::dist(ctr, A));
    }

    Circle inscribedCircle(){
        double r = 2 * this->area() / this->perimeter();
        Point A=vertices[0], B=vertices[1], C=vertices[2];
        double a = Point::dist(A, B), b = Point::dist(B, C), c = Point::dist(A, C);
        double x, y;
        x = (a*A.x + b*B.x + c*C.x) / (a + b + c);
        y = (a*A.y + b*B.y + c*C.y) / (a + b + c);
        return Circle(Point(x, y), r);
    }

    Point centroid() {
        Point A=vertices[0], B=vertices[1], C=vertices[2];
        return Point((A.x+B.x+C.x)/3, (A.y+B.y+C.y)/3);
    }

    Point orthocenter(){
        Point Ah = Line(vertices[1], vertices[2]).get_perp(vertices[0]);
        Point Ch = Line(vertices[0], vertices[1]).get_perp(vertices[2]);
        return Line::cross(Line(vertices[2], Ch), Line(vertices[0], Ah));
    }

    Circle ninePointsCircle(){
        Point Am((vertices[1].x+vertices[2].x)/2, (vertices[1].y+vertices[2].y)/2);
        Point Bm((vertices[0].x+vertices[2].x)/2, (vertices[0].y+vertices[2].y)/2);
        Point Cm((vertices[1].x+vertices[0].x)/2, (vertices[1].y+vertices[0].y)/2);
        Triangle T(Am, Bm, Cm);
        return T.circumscribedCircle();
    }

    Line EulerLine(){
        Point O1 = this->orthocenter(), O2 = this->ninePointsCircle().center();
        return Line(O1, O2);
    }

    double area() final{
        double angle = sin(Point::angle(vertices[0], vertices[1], vertices[2]));
        return 0.5 * Point::dist(vertices[0], vertices[1]) * Point::dist(vertices[1], vertices[2]) * angle;
    }
};


bool Polygon::containsPoint(Point point) {
    double res = 0;
    for (size_t i = 0; i < vertices.size(); ++i){
        Triangle T(point, vertices[i], vertices[(i+1) % vertices.size()]);
        res += T.area();
    }
    return res == this->area();
}


class Square : public Rectangle{
protected:
    vector <Point> vertices;

public:

    Square() = default;

    Square(vector <Point> &vert){
        vertices = vert;
    }

    Square(const Point &A, const Point &C, double k=1){
        double t = max(1/k, k);
        double x = (A.x + k * C.x) / (1 + t), y = (A.y + k * C.y) / (1 + t);
        Point B(x, y), D = B;
        ::reflex(D, Point((A.x+C.x)/2, (A.y+C.y)/2));
        vertices = {A, B, C, D};
    }

    Square(const Point& A, const Point& B, const Point& C, const Point& D) {
        vertices.push_back(A);
        vertices.push_back(B);
        vertices.push_back(C);
        vertices.push_back(D);
    }

    ~Square() override{
        vertices.clear();
        vertices.shrink_to_fit();
    }

    Circle circumscribedCircle(){
        Circle c(this->center(), Point::dist(this->center(), vertices[0]));
        return c;
    }

    Circle inscribedCircle(){
        Circle c(this->center(), Point::dist(this->vertices[0], this->vertices[1])/2);
        return c;
    }
};
/*
bool operator==(Circle& c, Ellipse& el) {
    return (abs(c.radius() - el.get_a()) <= PREC && abs(el.get_b() - c.radius()) <= PREC &&
        c.center() == el.focuses().first && el.focuses().first == el.focuses().second);
}

bool operator!=(Circle& c, Ellipse& el) {
    return !(c == el);
}

bool operator==(Ellipse& el, Circle& c) {
    return (abs(c.radius() - el.get_a()) <= PREC && abs(el.get_b() - c.radius()) <= PREC
        && c.center() == el.focuses().first && el.focuses().first == el.focuses().second);
}

bool operator!=(Ellipse& el, Circle& c) {
    return !(c == el);
}//*/
