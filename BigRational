#include <iostream>
#include <vector>
#include <string>

//+ - * / % OK
// * slow((

using namespace std;

const int Base = 10;

class BigInteger {
private:
    vector<int> data;

    bool is_positive = true;

    class DivideByZero: exception {};

    void zeroCheck() {
        int zeros = 0;
        bool is_zero = true;
        for (size_t i=0; i < this->data.size(); ++i){
            if (data[i] == 0) ++zeros;
            else {
                is_zero = false;
                break;
            }
        }
        if (is_zero) {
            this->data.resize(1, 0);
            this->is_positive = true;
        }
        else if (zeros){
            vector <int> new_data;
            for (size_t i=zeros; i < this->data.size(); ++i){
                new_data.push_back(this->data[i]);
            }
            this->data = new_data;
        }
    }

    static BigInteger Plus(const BigInteger& a, const BigInteger& b) {
        BigInteger result, left, right;
        if (a > b) {
            left = b;
            right = a;
        }
        else {
            left = a;
            right = b;
        }
        result.data.resize(max(left.data.size(), right.data.size()));
        int k = 0;
        size_t i;
        for (i = 0; i < left.data.size(); ++i) {
            result.data[result.data.size() - i - 1] =
                    (left.data[left.data.size() - i - 1] + right.data[right.data.size() - i - 1] + k) % Base;
            k = (left.data[left.data.size() - i - 1] + right.data[right.data.size() - i - 1] + k) / Base;
        }
        while (i < result.data.size()) {
            result.data[result.data.size() - i - 1] = (right.data[right.data.size() - i - 1] + k) % Base;
            k = (right.data[right.data.size() - i - 1] + k) / Base;
            i += 1;
        }
        if (k > 0)
            result.data.insert(result.data.begin(), k);
        return result;
    }

    static BigInteger Minus(const BigInteger& a, const BigInteger& b) {
        BigInteger result, left, right;
        if (a > b) {
            left = b;
            right = a;
        }
        else {
            left = a;
            right = b;
        }
        result.data.resize(right.data.size());
        int k = 0;
        size_t i;
        for (i = 0; i < left.data.size(); ++i) {
            result.data[result.data.size() - i - 1] =
                    (Base + right.data[right.data.size() - i - 1] - left.data[left.data.size() - i - 1] + k) % Base;
            k = (right.data[right.data.size() - i - 1] - left.data[left.data.size() - i - 1] + k);
            if (k < 0) k = -1;
            else k = 0;
        }
        while (i < result.data.size()) {
            result.data[result.data.size() - i - 1] = (Base + right.data[right.data.size() - i - 1] + k) % Base;
            k = (right.data[right.data.size() - i - 1] + k);
            if (k < 0) k = -1;
            else k = 0;
            i += 1;
        }
        if (k > 0)
            result.data.insert(result.data.begin(), abs(k));
        return result;
    }

    static BigInteger& Multiply(BigInteger &a, const BigInteger& b) {
        a.is_positive = (a.is_positive == b.is_positive);
        int k=0, m=0;
        for (size_t i = 0; i < a.data.size(); ++i) {
            m = (a.data[a.data.size() - i - 1] * b.data[0] + k) / Base;
            a.data[a.data.size() - i - 1] = (a.data[a.data.size() - i - 1] * b.data[0] + k) % Base;
            k = m;
        }
        if (k > 0){
            vector <int> tmp;
            tmp.push_back(k);
            for (int i : a.data){
                tmp.push_back(i);
            }
            a.data = tmp;
        }
        return a;
    }

public:
    BigInteger() = default;

    BigInteger &operator=(const BigInteger &right);

    explicit BigInteger(const string &s) {
        is_positive = (s[0] != '-');
        for (auto i : s) {
            if (i == '-') continue;
            data.push_back((int) i - '0');
        }
        zeroCheck();
    }

    BigInteger(const int &j) {
        is_positive = (j >= 0);
        int res = abs(j);
        while (res > 0){
            data.push_back(res % 10);
            res /= 10;
        }
        if (data.empty()) data.push_back(0);
        for (size_t i=0; i < data.size()/2; ++i) {
            swap(data[i], data[data.size() - i - 1]);
        }
        zeroCheck();
    }

    ~BigInteger() {
        data.clear();
    }

    static BigInteger abs1(const BigInteger& a){
        BigInteger res = a;
        res.is_positive = true;
        return res;
    }

    virtual explicit operator bool () const {
        vector <int> z(1, 0);
        return !(this->data == z);
    }

    virtual string toString() const {
        string s = (this->is_positive ? "" : "-" );
        for(int i : this->data)
            s += (to_string(i));
        if(this->data.empty()) s += '0';
        return s;
    }


    BigInteger &operator+=(const BigInteger &right);
    BigInteger &operator-=(const BigInteger &right);
    BigInteger &operator*=(const BigInteger &right);
    BigInteger &operator/=(const BigInteger &right);
    BigInteger &operator%=(const BigInteger &right);

    const BigInteger operator--(int);
    BigInteger operator--();
    const BigInteger operator++(int);
    BigInteger operator++();

    BigInteger operator-();
    BigInteger operator+() const;

    friend bool operator>(const BigInteger &left, const BigInteger &right);
};

BigInteger operator+(const BigInteger &left, const BigInteger &right);
BigInteger operator-(const BigInteger &left, const BigInteger &right);
BigInteger operator*(const BigInteger &left, const BigInteger &right);
BigInteger operator/(const BigInteger &left, const BigInteger &right);
BigInteger operator%(const BigInteger &left, const BigInteger &right);

bool operator==(const BigInteger &left, const BigInteger &right);
bool operator>=(const BigInteger &left, const BigInteger &right);
bool operator<=(const BigInteger &left, const BigInteger &right);
bool operator<(const BigInteger &left, const BigInteger &right);
bool operator>(const BigInteger &left, const BigInteger &right);
bool operator!=(const BigInteger &left, const BigInteger &right);

BigInteger operator+(const BigInteger &left, const BigInteger &r) {
    BigInteger result = left;
    result += r;
    return result;
}


istream& operator >> (std::istream &in, BigInteger &a)
{
    string s;
    in >> s;
    a = BigInteger(s);
    return in;
}

ostream& operator << (std::ostream &os, const BigInteger &a)
{
    return os << a.toString();
}

BigInteger BigInteger::operator+() const{
    return *this;
}


BigInteger operator-(const BigInteger &left, const BigInteger &r) {
    BigInteger result = left;
    result -= r;
    return result;
}

BigInteger &BigInteger::operator+=(const BigInteger &right) {
    BigInteger a = *this, b = right;
    a.is_positive = true;
    b.is_positive = true;
    if (this->is_positive && right.is_positive) {
        *this = Plus(a, b);
        this->is_positive = true;
    }
    else if (!this->is_positive && !right.is_positive){
        *this = Plus(a, b);
        this->is_positive = false;
    }
    else if (this->is_positive && !right.is_positive){
        *this = Minus(a, b);
        this->is_positive = (b <= a);
    }
    else if (!this->is_positive && right.is_positive){
        *this = Minus(a, b);
        this->is_positive = (a <= b);
    }
    this->zeroCheck();
    return *this;
}

BigInteger &BigInteger::operator-=(const BigInteger &right) {
    BigInteger a = *this, b = right;
    a.is_positive = true;
    b.is_positive = true;
    if (this->is_positive == right.is_positive) {
        bool k = (*this > right);
        *this = Minus(abs1(*this), abs1(right));
        this->is_positive = k;
    }
    else if (this->is_positive && !right.is_positive){
        *this = Plus(a, b);
        this->is_positive = true;
    }
    else if (!this->is_positive && right.is_positive){
        *this = Plus(a, b);
        this->is_positive = false;
    }
    this->zeroCheck();
    return *this;
}

BigInteger &BigInteger::operator=(const BigInteger &right) {
    if (this == &right) {
        return *this;
    }
    this->data = right.data;
    this->is_positive = right.is_positive;
    this->zeroCheck();
    return *this;
}

BigInteger BigInteger::operator-() {
    this->is_positive = !this->is_positive;
    this->zeroCheck();
    return *this;
}

bool operator==(const BigInteger &left, const BigInteger &right) {
    return !(left > right) && !(left < right);
}

bool operator>(const BigInteger &left, const BigInteger &right) {
    if (left.is_positive){
        if (!right.is_positive) return true;
        if (right.data.size() > left.data.size()) return false;
        if (left.data.size() > right.data.size()) return true;
        for (size_t i=0; i < left.data.size(); ++i){
            if (left.data[i] < right.data[i]) return false;
            if (left.data[i] > right.data[i]) return true;
        }
        return false;
    }
    else{
        if (!right.is_positive) return false;
        if (right.data.size() < left.data.size()) return false;
        if (left.data.size() < right.data.size()) return true;
        for (size_t i=0; i < left.data.size(); ++i){
            if (left.data[i] > right.data[i]) return false;
            if (left.data[i] < right.data[i]) return true;
        }
        return false;
    }
}

bool operator<(const BigInteger &left, const BigInteger &right) {
    return right > left;
}

bool operator<=(const BigInteger &left, const BigInteger &right) {
    return left < right || left == right;
}

bool operator>=(const BigInteger &left, const BigInteger &right) {
    return left == right || left > right;
}

BigInteger BigInteger::operator++() {
    return *this + 1;
}

const BigInteger BigInteger::operator++(int){
    BigInteger oldValue = *this;
    *this += 1;
    this->zeroCheck();
    return oldValue;
}

BigInteger BigInteger::operator--() {
    return *this - 1;
}

const BigInteger BigInteger::operator--(int) {
    BigInteger oldValue = *this;
    *this -= 1;
    this->zeroCheck();
    return oldValue;
}

BigInteger operator/(const BigInteger &left, const BigInteger &right) {
    BigInteger res = left;
    res /= right;
    return res;
}

BigInteger operator*(const BigInteger &left, const BigInteger &right) {
    BigInteger res = left;
    res *= right;
    return res;
}

BigInteger &BigInteger::operator*=(const BigInteger &right) {
    if (this->data.size() == 1 && right.data.size() == 1){
        bool k = (this->is_positive == right.is_positive);
        *this = BigInteger(to_string(this->data[0] * right.data[0]));
        this->is_positive = k;
        return *this;
    }
    if (this->data.empty() || right.data.empty() || *this == 0 || right == 0) {
        *this = 0;
        return *this;
    }
    if (right.data.size() == 1){
        return Multiply(*this, right);
    }
    if (this->data.size() == 1){
        BigInteger tmp = right;
        *this = Multiply(tmp, *this);
        return *this;
    }
    bool k = (this->is_positive == right.is_positive);
    BigInteger A0, B0;
    for (size_t i=0; i < this->data.size() / 2; ++i){
        A0.data.push_back(this->data[i]);
    }
    for (size_t i=0; i < right.data.size() / 2; ++i){
        B0.data.push_back(right.data[i]);
    }
    BigInteger A1, B1;
    for (size_t i=this->data.size() / 2; i < this->data.size(); ++i){
        A1.data.push_back(this->data[i]);
    }
    for (size_t i=right.data.size() / 2; i < right.data.size(); ++i){
        B1.data.push_back(right.data[i]);
    }
    size_t a = A1.data.size(), b = B1.data.size();
    A0.zeroCheck();
    A1.zeroCheck();
    B0.zeroCheck();
    B1.zeroCheck();
    BigInteger C0 = A0 * B0, C1 = A0 * B1, C2 = A1 * B0;
    for (size_t i = 0; i < b; ++i) {
        C2.data.push_back(0);
        C0.data.push_back(0);
    }
    for (size_t i = 0; i < a; ++i) {
        C1.data.push_back(0);
        C0.data.push_back(0);
    }
    *this = A1 * B1 + C0 + C1 + C2;
    this->is_positive = k;
    this->zeroCheck();
    return *this;
}

BigInteger &BigInteger::operator/=(const BigInteger &right) {
    if (right == 0) {
        throw BigInteger::DivideByZero();
    }
    bool k = (this->is_positive && right.is_positive) or (!this->is_positive && !right.is_positive);
    BigInteger res;
    BigInteger curValue;
    for (int j : this->data) {
        if (curValue < abs1(right)) curValue.data.push_back(j);
        else break;
    }
    size_t i = curValue.data.size();
    do {
        curValue.zeroCheck();
        int mid = 0;
        int lBorder = 0;
        int rBorder = Base;
        while (lBorder < rBorder - 1) {
            mid = (lBorder + rBorder) / 2;
            BigInteger cur = abs1(right) * mid;
            if (cur <= curValue) {
                lBorder = mid;
            } else {
                rBorder = mid;
            }
        }
        res.data.push_back(lBorder);
        curValue -= abs1(right) * lBorder;
        if (i < this->data.size())curValue.data.push_back(this->data[i]);
        ++i;
    } while (i <= this->data.size());
    res.zeroCheck();
    *this = res;
    this->is_positive = k;
    this->zeroCheck();
    return *this;
}



BigInteger operator%(const BigInteger &left, const BigInteger &right) {
    BigInteger res = left;
    res %= right;
    return res;
}


BigInteger &BigInteger::operator%=(const BigInteger &right) {
    BigInteger res;
    *this -= (*this / right) * right;
    if (!this->is_positive) {
        res = res + right;
    }
    this->is_positive = true;
    this->zeroCheck();
    return *this;
}

bool operator!=(const BigInteger &left, const BigInteger &right) {
    return !(left == right);
}




/*/////////////////////////////////////////////////////////////////////////////////////

                                Rational

/////////////////////////////////////////////////////////////////////////////////////*/



class Rational {
private:

    BigInteger nominator=0, denominator=1;

    class DivideByZero: exception {};

    static void reduce(Rational &r) {
        if (r.nominator != 0) {
            BigInteger numFirst;
            numFirst = BigInteger::abs1(r.nominator);
            BigInteger numSecond = r.denominator;
            if (numSecond > numFirst) {
                swap(numFirst, numSecond);
            }
            while (numFirst % numSecond) {
                numFirst = numFirst % numSecond;
                swap(numFirst, numSecond);
            }
            r.nominator = r.nominator / numSecond;
            r.denominator = r.denominator / numSecond;
        } else {
            r.denominator = 1;
        }
    }


    static void Check(Rational &r) {
        if (r.denominator < 0){
            r.nominator *= -1;
            r.denominator *= -1;
        }
        if (r.nominator == 0) r.denominator = 1;
        reduce(r);
    }

public:
    Rational() = default;

    Rational &operator=(const Rational &right);

    explicit Rational(const BigInteger &p, const BigInteger &q) {
        nominator = p;
        denominator = q;
        if (q == 0)
            throw DivideByZero();
        Check(*this);
    }

    Rational(const BigInteger &i) {
        nominator = i;
        denominator = 1;
    }

    Rational(const int &i) {
        nominator = i;
        denominator = 1;
    }

    explicit operator bool () const {
        return this->nominator != 0;
    }

    string toString() const {
        if (this->denominator == 1)
            return this->nominator.toString();
        string s =  this->nominator.toString() + '/' + this->denominator.toString();
        return s;
    }

    Rational &operator+=(const Rational &right);
    Rational &operator-=(const Rational &right);
    Rational &operator*=(const Rational &right);
    Rational &operator/=(const Rational &right);


    const Rational operator--(int);
    Rational operator--();
    const Rational operator++(int);
    Rational operator++();

    Rational operator-();
    Rational operator+() const;

    friend bool operator>(const Rational &left, const Rational &right);

    string asDecimal(size_t precision = 0) const {
        string s;
        BigInteger q = 10;
        for (size_t i=0; i < precision; ++i){
            q *= 10;
        }
        Rational r(5, q);
        if (0 > *this) r = -r;
        r += *this;
        s = (r.nominator / r.denominator).toString() + ',';
        BigInteger left = BigInteger::abs1(r.nominator) % r.denominator;
        for (size_t i=0; i <= precision; ++i){
            s += ((left * 10) / r.denominator).toString();
            left *= 10;
            left %= r.denominator;
        }
        s.erase(s.size() - 1, 1);
        if (s[s.size() - 1] == ',') {
            s.erase(s.size() - 1, 1);
        }
        if (this->nominator < 0 && s[0] != '-') s = '-' + s;
        return s;
    }
};

Rational operator+(const Rational &left, const Rational &right);
Rational operator-(const Rational &left, const Rational &right);
Rational operator*(const Rational &left, const Rational &right);
Rational operator/(const Rational &left, const Rational &right);

bool operator==(const Rational &left, const Rational &right);
bool operator>=(const Rational &left, const Rational &right);
bool operator<=(const Rational &left, const Rational &right);
bool operator<(const Rational &left, const Rational &right);
bool operator>(const Rational &left, const Rational &right);
bool operator!=(const Rational &left, const Rational &right);


Rational operator+(const Rational &left, const Rational &r) {
    Rational result = left;
    result += r;
    return result;
}


istream& operator >> (std::istream &in, Rational &a)
{
    string s;
    in >> s;
    BigInteger p=0, q=0;
    size_t i;
    for (i = (s[0] == '-'); i < s.size() && s[i] != '/'; ++i){
        p = p*10 + (int) s[i] - '0';
    }
    if (s[0] == '-') p = -p;
    if (i == s.size()) q = 1;
    ++i;
    int j = i;
    for (i = i + (s[i] == '-'); i < s.size(); ++i){
        q = q*10 + (int) s[i] - '0';
    }
    if (s[j] == '-') p = -p;
    a = Rational(p, q);
    return in;
}

ostream& operator << (std::ostream &os, const Rational &a)
{
    return os << a.toString();
}

Rational Rational::operator+() const{
    return *this;
}


Rational operator-(const Rational &left, const Rational &r) {
    Rational result = left;
    result -= r;
    return result;
}

Rational &Rational::operator+=(const Rational &right) {
    *this = Rational(this->nominator * right.denominator + this->denominator * right.nominator,
                     this->denominator * right.denominator);
    Check(*this);
    return *this;
}

Rational &Rational::operator-=(const Rational &right) {
    *this = Rational(this->nominator * right.denominator - this->denominator * right.nominator,
                     this->denominator * right.denominator);
    Check(*this);
    return *this;
}

Rational &Rational::operator=(const Rational &right) {
    if (this == &right) {
        return *this;
    }
    this->nominator = right.nominator;
    this->denominator = right.denominator;
    Check(*this);
    return *this;
}

Rational Rational::operator-() {
    this->nominator = -this->nominator;
    Check(*this);
    return *this;
}

bool operator==(const Rational &left, const Rational &right) {
    return !(left > right) && !(left < right);
}

bool operator>(const Rational &left, const Rational &right) {
    return left.nominator * right.denominator > left.denominator * right.nominator;
}

bool operator<(const Rational &left, const Rational &right) {
    return right > left;
}

bool operator<=(const Rational &left, const Rational &right) {
    return left < right || left == right;
}

bool operator>=(const Rational &left, const Rational &right) {
    return left == right || left > right;
}

Rational Rational::operator++() {
    return *this + 1;
}

const Rational Rational::operator++(int){
    Rational oldValue = *this;
    *this += 1;
    Check(*this);
    return oldValue;
}

Rational Rational::operator--() {
    return *this - 1;
}

const Rational Rational::operator--(int) {
    Rational oldValue = *this;
    *this -= 1;
    Check(*this);
    return oldValue;
}

Rational operator/(const Rational &left, const Rational &right) {
    Rational res = left;
    res /= right;
    return res;
}

Rational operator*(const Rational &left, const Rational &right) {
    Rational res = left;
    res *= right;
    return res;
}

Rational &Rational::operator*=(const Rational &right) {
    *this = Rational(this->nominator * right.nominator, this->denominator * right.denominator);
    Check(*this);
    return *this;
}

Rational &Rational::operator/=(const Rational &right) {
    if (right == 0) {
        throw Rational::DivideByZero();
    }
    *this = Rational(this->nominator * right.denominator, this->denominator * right.nominator);
    Check(*this);
    return *this;
}

bool operator!=(const Rational &left, const Rational &right) {
    return !(left == right);
}

#include <cstdlib>
#include <ctime>

int main() {

    srand(time(nullptr) / 2);
    long long i=0;
    while (i < 10000){
        ++i;
        long double p = rand() % 100, q = rand() % 100, r = rand() % 100, s = rand() % 100;
        if (rand() % 2) p = -p;
        if (rand() % 2) r = -r;
        if (q == 0) q = 1;
        if (s == 0) s = 1;
        Rational a((int) p, (int) q), b((int) r, (int) s), c;
        double k = p/q, m = r/s;
        //Rational a, b, c;
        //cin >> a >> b;
        c = a-b;
        if ((a/b).asDecimal(5) != to_string(k+m)) {
            cout << p << " " << q << " " << r  << " " << s << endl;
            cout << (a+b).asDecimal(6) << " " << to_string(k+m) << endl;
        }
    }
    return 0;
}

//-42 72 12 15
